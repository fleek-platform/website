---
import BaseHtml from '@layouts/BaseHtml.astro';
import Templates from '@components/Templates';
import {
  fetchTemplates,
  type Template,
} from '@utils/graphql-client/fetchTemplates';
import { getRepository, randomizeArray } from '@utils/templates';

const graphqlApiUrl = import.meta.env.PUBLIC_GRAPHQL_ENDPOINT;

if (!graphqlApiUrl) {
  throw new Error('GraphQL API URL is required to fetch the templates');
}

export async function getStaticPaths() {
  // must repeat, getStaticPaths can't use local vars
  const graphqlApiUrl = import.meta.env.PUBLIC_GRAPHQL_ENDPOINT;
  const response = await fetchTemplates(graphqlApiUrl);

  if (!response.success) {
    throw new Error(response.error.message);
  }

  if (!response.data) {
    throw new Error('Failed to fetch the templates');
  }

  const { data: templates } = response.data;

  const paths = templates.map((template) => ({
    params: { slug: template.siteSlug },
    props: { template },
  }));

  return paths;
}

const { template } = Astro.props;
const { id, name, description, banner, siteSlug, deployment } = template;

/*------------------ Readme content -----------------*/

type ReadmeResult = {
  content?: string;
  error?: 'no-readme' | 'error';
};

const fetchReadmeContent = async (
  repoOwner: string,
  repoSlug: string,
): Promise<ReadmeResult> => {
  if (!(repoOwner && repoSlug)) {
    console.error(
      `repoOwner: ${repoOwner} and repoSlug: ${repoSlug} must be provided`,
    );
    return { error: 'error' };
  }

  const url = `https://api.github.com/repos/${repoOwner}/${repoSlug}/readme`;

  const headers = {
    'User-Agent': 'octokit.js/2.1.0 octokit-core.js/4.2.4 Mozilla/5.0',
    Accept: 'application/vnd.github.v3+json',
  };

  const response = await fetch(url, { headers });
  if (response.status === 404) {
    return { error: 'no-readme' };
  }

  if (!response.ok) {
    console.error(`HTTP error! status: ${response.status}`);
    return { error: 'error' };
  }

  const data = await response.json();
  if (!data.content) {
    return { error: 'error' };
  }

  const decodedContent = Buffer.from(data.content, 'base64').toString('utf-8');
  return { content: decodedContent };
};

const repository = getRepository(template);

// repository.owner = 'fleekxyz';
// repository.slug = 'astro-template';

const readmeResult = await fetchReadmeContent(
  repository.owner!,
  repository.slug!,
);

/*------------------ Similar templates -----------------*/

const getSimilarTemplates = async (): Promise<Template[]> => {
  const response = await fetchTemplates(graphqlApiUrl);

  if (!response.success) {
    throw new Error(response.error.message);
  }

  if (!response.data) {
    throw new Error('Failed to fetch the templates');
  }

  const { data: templates } = response.data;

  // get 3 random templates that are not the current template
  const otherTemplates = templates.filter(
    (otherTemplate) => otherTemplate.id !== template.id,
  );

  const similarTemplates = randomizeArray(otherTemplates).slice(0, 3);

  return similarTemplates;
};

const similarTemplates = await getSimilarTemplates();

const screenshot = deployment.previewImageUrl;
---

<BaseHtml
  title={name}
  ogMeta={{
    title: name,
    description,
    image: banner,
    slug: `templates/${siteSlug}`,
  }}
  customContentWrapperClass="px-32 xl:px-0"
>
  <main class="container flex flex-col gap-20 sm:flex-row sm:flex-wrap">
    <div class="flex-1">
      <Templates.TemplateDetails.TopActions client:load templateId={id} />
      <Templates.TemplateDetails.TemplateHero template={template} />
    </div>

    <div class="flex max-w-full flex-col gap-20 overflow-hidden sm:flex-row">
      <div
        class="flex min-w-0 flex-1 flex-col gap-20 sm:flex-shrink sm:flex-grow"
      >
        {
          !readmeResult.error && readmeResult.content && (
            <Templates.TemplateDetails.TemplateReadme
              readmeContent={readmeResult.content}
            />
          )
        }
        {
          readmeResult.error === 'no-readme' && (
            <Templates.TemplateDetails.TemplateNoReadme />
          )
        }
        {
          readmeResult.error === 'error' && (
            <Templates.TemplateDetails.TemplateReadmeError />
          )
        }
        {
          screenshot && (
            <Templates.TemplateDetails.TemplateScreenshot
              screenShotUrl={screenshot}
            />
          )
        }
      </div>

      <div class="flex-none sm:max-w-[242px]">
        <Templates.TemplateDetails.TemplateSpecs template={template} />
      </div>
    </div>

    <div class="flex-1">
      <div class="separator my-60 border-b-1 border-b-neutral-8"></div>
      <Templates.TemplateDetails.SimilarTemplates
        templates={similarTemplates}
      />
    </div>
  </main>
</BaseHtml>
